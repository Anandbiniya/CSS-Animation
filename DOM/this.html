<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>This Key word</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <h1>This key word</h1>

    <script>
      //when it comes to object biniding there are two types implicit
      //Explain this keyword
      // this key word use to reference something like an object everything in js is object even function are first class object
      this.a = 5;
      //console.log(this.a); //we can see 5
      //console.log(this); //we can see window object;
      //this if it inside the function
      function getParams() {
        console.log(this.a); //this key word first target the function object if it is did not find it will go to function parent object and get acces of value 5
      }
      getParams();
      const arrget = () => {
        console.log(this.a);
      };
      arrget(); //the out put will be 5 only because here the window object is this.a which is exist in globally

      //behaviorial of this  key word in the object
      let user = {
        name: "anand",
        age: 23,
        getdetails() {
          // console.log(this.name);
        },
      };
      user.getdetails(); //Implicit Binding
      //normal function will only point to immediate parent

      // A function's this keyword behaves a little differently in JavaScript compared to other languages. It also has some differences between strict mode and non-strict mode.

      const test = {
        prop: 42,
        func: function () {
          return this.prop;
        },
      };

      // console.log(test.func());
      // expected output: 42
      //this is always a reference to an object. In strict mode, it can be any value.The value of this depends on in which context it appears: function, class, or global.
      let User = {
        name: "Piyush",
        age: 24,
        getDetails() {
          const nestedArrow = () => console.log(this.name); //Piyush
          nestedArrow();
        },
      };
      User.getDetails(); // gives "Piyush" as the output since it points to the parent's context i.e. the user object.

      let arrow = {
        name: "bu",
        age: 9,
        gug: () => {
          const nestedgig = () => console.log(this.name);
          nestedgig();
        },
      };
      //you dont

      arrow.gug(); //still has doubt related to this
      //this in class
      class users {
        constructor(n, a) {
          this.name = n;
          this.age = a;
        }
        getName() {
          console.log(this.name);
        }
      }

      const new_user = new users("piyush", "amith"); //A constructor is a special function that creates and initializes an object instance of a class.
      new_user.gender = "male";
      new_user.getName();
      console.log(new_user); //In constructor function we can create an object as wekll as modified the objects

      function constructoruser() {
        this.name = "Bob";
      }

      var user1 = new constructoruser();
      var user2 = new constructoruser();
      user1.name = "po";
      console.log(user1);
      console.log(user2);
      // Properties and methods can be added to a constructor using a prototype:
      //Constructor
      function ProUser() {
        this.name = "Bob";
      }

      let ProUser1 = new ProUser();
      let ProUser2 = new ProUser();

      //Adding property to constructor using prototype
      ProUser.prototype.age = 25;

      console.log(ProUser1.age); // 25
      console.log(ProUser2.age); // 25

      //OutputBasedquestions
      const int = {
        firstName: "abhi lol",
        getNames() {
          const firstName = "abhi";
          return this.firstName;
        },
      };
      console.log(int.getNames()); //this will print abhilol because this will be pointing the int object

      //what is the result of accesing its ref and why
      function MakeUser() {
        return {
          name: "john",
          ref: this,
        };
      }
      let makeusernew = MakeUser();
      console.log(makeusernew); //how will we fix the problems so the reference names should get john in the out put

      //    function MakeUser() {
      //   return {
      //     name: "john",
      //    ref(){
      //return this

      // }
      //   };
      // }
      //and call the function
      // let makeusernew = MakeUser();

      //another output based question
      const loguser = {
        name: "aman agarwal",
        logMessage() {
          console.log(this.name);
        },
      };

      setTimeout(loguser.logMessage, 1000);
      //workout
    </script>
  </body>
</html>
